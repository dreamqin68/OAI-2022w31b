{
  "$schema": "https://aka.ms/codetour-schema",
  "title": "UE_log_step1",
  "steps": [
    {
      "file": "executables/nr-uesoftmodem.c",
      "description": "executables/nr-uesoftmodem.c/main() Line 436 (call get_common_options())",
      "line": 436,
      "contents": "/*\n * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The OpenAirInterface Software Alliance licenses this file to You under\n * the OAI Public License, Version 1.1  (the \"License\"); you may not use this file\n * except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.openairinterface.org/?page_id=698\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *-------------------------------------------------------------------------------\n * For more information about the OpenAirInterface (OAI) Software Alliance:\n *      contact@openairinterface.org\n */\n\n\n#define _GNU_SOURCE             /* See feature_test_macros(7) */\n#include <sched.h>\n\n#include \"T.h\"\n#include \"assertions.h\"\n#include \"PHY/types.h\"\n#include \"PHY/defs_nr_UE.h\"\n#include \"SCHED_NR_UE/defs.h\"\n#include \"common/ran_context.h\"\n#include \"common/config/config_userapi.h\"\n//#include \"common/utils/threadPool/thread-pool.h\"\n#include \"common/utils/load_module_shlib.h\"\n//#undef FRAME_LENGTH_COMPLEX_SAMPLES //there are two conflicting definitions, so we better make sure we don't use it at all\n#include \"common/utils/nr/nr_common.h\"\n\n#include \"../../ARCH/COMMON/common_lib.h\"\n#include \"../../ARCH/ETHERNET/USERSPACE/LIB/if_defs.h\"\n\n//#undef FRAME_LENGTH_COMPLEX_SAMPLES //there are two conflicting definitions, so we better make sure we don't use it at all\n#include \"openair1/PHY/MODULATION/nr_modulation.h\"\n#include \"PHY/phy_vars_nr_ue.h\"\n#include \"PHY/NR_UE_TRANSPORT/nr_transport_proto_ue.h\"\n#include \"SCHED/sched_common_vars.h\"\n#include \"PHY/MODULATION/modulation_vars.h\"\n#include \"PHY/NR_TRANSPORT/nr_dlsch.h\"\n//#include \"../../SIMU/USER/init_lte.h\"\n\n#include \"LAYER2/MAC/mac_vars.h\"\n#include \"RRC/LTE/rrc_vars.h\"\n#include \"PHY_INTERFACE/phy_interface_vars.h\"\n#include \"NR_IF_Module.h\"\n#include \"openair1/SIMULATION/TOOLS/sim.h\"\n\n#ifdef SMBV\n#include \"PHY/TOOLS/smbv.h\"\nunsigned short config_frames[4] = {2,9,11,13};\n#endif\n#include \"common/utils/LOG/log.h\"\n#include \"common/utils/LOG/vcd_signal_dumper.h\"\n\n#include \"UTIL/OPT/opt.h\"\n#include \"enb_config.h\"\n\n#include \"intertask_interface.h\"\n\n#include \"PHY/INIT/phy_init.h\"\n#include \"system.h\"\n#include <openair2/RRC/NR_UE/rrc_proto.h>\n#include <openair2/LAYER2/NR_MAC_UE/mac_defs.h>\n#include <openair2/LAYER2/NR_MAC_UE/mac_proto.h>\n#include <openair2/NR_UE_PHY_INTERFACE/NR_IF_Module.h>\n#include <openair1/SCHED_NR_UE/fapi_nr_ue_l1.h>\n\n/* Callbacks, globals and object handlers */\n\n//#include \"stats.h\"\n// current status is that every UE has a DL scope for a SINGLE eNB (eNB_id=0)\n#include \"PHY/TOOLS/phy_scope_interface.h\"\n#include \"PHY/TOOLS/nr_phy_scope.h\"\n#include <executables/nr-uesoftmodem.h>\n#include \"executables/softmodem-common.h\"\n#include \"executables/thread-common.h\"\n\n#include \"nr_nas_msg_sim.h\"\n#include <openair1/PHY/MODULATION/nr_modulation.h>\n\nextern const char *duplex_mode[];\nTHREAD_STRUCT thread_struct;\nnrUE_params_t nrUE_params;\n\n// Thread variables\npthread_cond_t nfapi_sync_cond;\npthread_mutex_t nfapi_sync_mutex;\nint nfapi_sync_var=-1; //!< protected by mutex \\ref nfapi_sync_mutex\nuint16_t sf_ahead=6; //??? value ???\npthread_cond_t sync_cond;\npthread_mutex_t sync_mutex;\nint sync_var=-1; //!< protected by mutex \\ref sync_mutex.\nint config_sync_var=-1;\n\n// not used in UE\ninstance_t CUuniqInstance=0;\ninstance_t DUuniqInstance=0;\n\nRAN_CONTEXT_t RC;\nvolatile int             oai_exit = 0;\n\n\nextern int16_t  nr_dlsch_demod_shift;\nstatic int      tx_max_power[MAX_NUM_CCs] = {0};\n\nint      single_thread_flag = 1;\nint                 tddflag = 0;\nint                 vcdflag = 0;\n\ndouble          rx_gain_off = 0.0;\nchar             *usrp_args = NULL;\nchar       *rrc_config_path = NULL;\nchar            *uecap_file = NULL;\nint               dumpframe = 0;\n\nuint64_t        downlink_frequency[MAX_NUM_CCs][4];\nint32_t         uplink_frequency_offset[MAX_NUM_CCs][4];\nint             rx_input_level_dBm;\n\n#if MAX_NUM_CCs == 1\nrx_gain_t                rx_gain_mode[MAX_NUM_CCs][4] = {{max_gain,max_gain,max_gain,max_gain}};\ndouble tx_gain[MAX_NUM_CCs][4] = {{20,0,0,0}};\ndouble rx_gain[MAX_NUM_CCs][4] = {{110,0,0,0}};\n#else\nrx_gain_t                rx_gain_mode[MAX_NUM_CCs][4] = {{max_gain,max_gain,max_gain,max_gain},{max_gain,max_gain,max_gain,max_gain}};\ndouble tx_gain[MAX_NUM_CCs][4] = {{20,0,0,0},{20,0,0,0}};\ndouble rx_gain[MAX_NUM_CCs][4] = {{110,0,0,0},{20,0,0,0}};\n#endif\n\n// UE and OAI config variables\n\nopenair0_config_t openair0_cfg[MAX_CARDS];\nint16_t           node_synch_ref[MAX_NUM_CCs];\nint               otg_enabled;\ndouble            cpuf;\n\n\nint          chain_offset = 0;\nint           card_offset = 0;\nuint64_t num_missed_slots = 0; // counter for the number of missed slots\nint     transmission_mode = 1;\nint            numerology = 0;\nint           oaisim_flag = 0;\nint            emulate_rf = 0;\nuint32_t       N_RB_DL    = 106;\n\n/* see file openair2/LAYER2/MAC/main.c for why abstraction_flag is needed\n * this is very hackish - find a proper solution\n */\nuint8_t abstraction_flag=0;\n\nnr_bler_struct nr_bler_data[NR_NUM_MCS];\n\nstatic void init_bler_table(void);\n\n/*---------------------BMC: timespec helpers -----------------------------*/\n\nstruct timespec min_diff_time = { .tv_sec = 0, .tv_nsec = 0 };\nstruct timespec max_diff_time = { .tv_sec = 0, .tv_nsec = 0 };\n\nstruct timespec clock_difftime(struct timespec start, struct timespec end) {\n  struct timespec temp;\n\n  if ((end.tv_nsec-start.tv_nsec)<0) {\n    temp.tv_sec = end.tv_sec-start.tv_sec-1;\n    temp.tv_nsec = 1000000000+end.tv_nsec-start.tv_nsec;\n  } else {\n    temp.tv_sec = end.tv_sec-start.tv_sec;\n    temp.tv_nsec = end.tv_nsec-start.tv_nsec;\n  }\n\n  return temp;\n}\n\nvoid print_difftimes(void) {\n  LOG_I(HW,\"difftimes min = %lu ns ; max = %lu ns\\n\", min_diff_time.tv_nsec, max_diff_time.tv_nsec);\n}\n\nint create_tasks_nrue(uint32_t ue_nb) {\n  LOG_D(NR_RRC, \"%s(ue_nb:%d)\\n\", __FUNCTION__, ue_nb);\n  itti_wait_ready(1);\n\n  if (ue_nb > 0) {\n    LOG_I(NR_RRC,\"create TASK_RRC_NRUE \\n\");\n    if (itti_create_task (TASK_RRC_NRUE, rrc_nrue_task, NULL) < 0) {\n      LOG_E(NR_RRC, \"Create task for RRC UE failed\\n\");\n      return -1;\n    }\n    if (get_softmodem_params()->nsa) {\n      init_connections_with_lte_ue();\n      if (itti_create_task (TASK_RRC_NSA_NRUE, recv_msgs_from_lte_ue, NULL) < 0) {\n        LOG_E(NR_RRC, \"Create task for RRC NSA nr-UE failed\\n\");\n        return -1;\n      }\n    }\n    if (itti_create_task (TASK_NAS_NRUE, nas_nrue_task, NULL) < 0) {\n      LOG_E(NR_RRC, \"Create task for NAS UE failed\\n\");\n      return -1;\n    }\n  }\n\n  itti_wait_ready(0);\n  return 0;\n}\n\nvoid exit_function(const char *file, const char *function, const int line, const char *s) {\n  int CC_id;\n\n  if (s != NULL) {\n    printf(\"%s:%d %s() Exiting OAI softmodem: %s\\n\",file,line, function, s);\n  }\n\n  oai_exit = 1;\n\n  if (PHY_vars_UE_g && PHY_vars_UE_g[0]) {\n    for(CC_id=0; CC_id<MAX_NUM_CCs; CC_id++) {\n      if (PHY_vars_UE_g[0][CC_id] && PHY_vars_UE_g[0][CC_id]->rfdevice.trx_end_func)\n        PHY_vars_UE_g[0][CC_id]->rfdevice.trx_end_func(&PHY_vars_UE_g[0][CC_id]->rfdevice);\n    }\n  }\n\n  sleep(1); //allow lte-softmodem threads to exit first\n  exit(1);\n}\n\nuint64_t get_nrUE_optmask(void) {\n  return nrUE_params.optmask;\n}\n\nuint64_t set_nrUE_optmask(uint64_t bitmask) {\n  nrUE_params.optmask = nrUE_params.optmask | bitmask;\n  return nrUE_params.optmask;\n}\n\nnrUE_params_t *get_nrUE_params(void) {\n  return &nrUE_params;\n}\n/* initialie thread pools used for NRUE processing paralleliation */ \nvoid init_tpools(uint8_t nun_dlsch_threads) {\n  char params[NR_RX_NB_TH*NR_NB_TH_SLOT*3+1]={0};\n  for (int i=0; i<NR_RX_NB_TH*NR_NB_TH_SLOT; i++) {\n    memcpy(params+(i*3),\"-1,\",3);\n  }\n  if (getenv(\"noThreads\")) {\n     initTpool(\"n\", &(nrUE_params.Tpool), false);\n     init_dlsch_tpool(0);\n   } else {\n     initTpool(params, &(nrUE_params.Tpool), false);\n     init_dlsch_tpool( nun_dlsch_threads);\n   }\n}\nstatic void get_options(void) {\n\n  paramdef_t cmdline_params[] =CMDLINE_NRUEPARAMS_DESC ;\n  int numparams = sizeof(cmdline_params)/sizeof(paramdef_t);\n  config_get(cmdline_params,numparams,NULL);\n  config_process_cmdline( cmdline_params,numparams,NULL);\n\n  if (vcdflag > 0)\n    ouput_vcd = 1;\n}\n\n// set PHY vars from command line\nvoid set_options(int CC_id, PHY_VARS_NR_UE *UE){\n  NR_DL_FRAME_PARMS *fp       = &UE->frame_parms;\n  paramdef_t cmdline_params[] = CMDLINE_NRUE_PHYPARAMS_DESC ;\n  int numparams               = sizeof(cmdline_params)/sizeof(paramdef_t);\n\n  UE->mode = normal_txrx;\n\n  config_get(cmdline_params,numparams,NULL);\n\n  int pindex = config_paramidx_fromname(cmdline_params,numparams, CALIBRX_OPT);\n  if ( (cmdline_params[pindex].paramflags &  PARAMFLAG_PARAMSET) != 0) UE->mode = rx_calib_ue;\n  \n  pindex = config_paramidx_fromname(cmdline_params,numparams, CALIBRXMED_OPT);\n  if ( (cmdline_params[pindex].paramflags &  PARAMFLAG_PARAMSET) != 0) UE->mode = rx_calib_ue_med;\n\n  pindex = config_paramidx_fromname(cmdline_params,numparams, CALIBRXBYP_OPT);              \n  if ( (cmdline_params[pindex].paramflags &  PARAMFLAG_PARAMSET) != 0) UE->mode = rx_calib_ue_byp;\n\n  pindex = config_paramidx_fromname(cmdline_params,numparams, DBGPRACH_OPT); \n  if (cmdline_params[pindex].uptr)\n    if ( *(cmdline_params[pindex].uptr) > 0) UE->mode = debug_prach;\n\n  pindex = config_paramidx_fromname(cmdline_params,numparams,NOL2CONNECT_OPT ); \n  if (cmdline_params[pindex].uptr)\n    if ( *(cmdline_params[pindex].uptr) > 0)  UE->mode = no_L2_connect;\n\n  pindex = config_paramidx_fromname(cmdline_params,numparams,CALIBPRACH_OPT );\n  if (cmdline_params[pindex].uptr)\n    if ( *(cmdline_params[pindex].uptr) > 0) UE->mode = calib_prach_tx;\n\n  pindex = config_paramidx_fromname(cmdline_params,numparams,DUMPFRAME_OPT );\n  if ((cmdline_params[pindex].paramflags & PARAMFLAG_PARAMSET) != 0)\n    UE->mode = rx_dump_frame;\n\n  // Init power variables\n  tx_max_power[CC_id] = tx_max_power[0];\n  rx_gain[0][CC_id]   = rx_gain[0][0];\n  tx_gain[0][CC_id]   = tx_gain[0][0];\n\n  // Set UE variables\n  UE->rx_total_gain_dB     = (int)rx_gain[CC_id][0] + rx_gain_off;\n  UE->tx_total_gain_dB     = (int)tx_gain[CC_id][0];\n  UE->tx_power_max_dBm     = tx_max_power[CC_id];\n  UE->rf_map.card          = card_offset;\n  UE->rf_map.chain         = CC_id + chain_offset;\n\n  LOG_I(PHY,\"Set UE mode %d, UE_fo_compensation %d, UE_scan_carrier %d, UE_no_timing_correction %d \\n, chest-freq %d\\n\",\n  \t   UE->mode, UE->UE_fo_compensation, UE->UE_scan_carrier, UE->no_timing_correction, UE->chest_freq);\n\n  // Set FP variables\n\n  if (tddflag){\n    fp->frame_type = TDD;\n    LOG_I(PHY, \"Set UE frame_type %d\\n\", fp->frame_type);\n  }\n\n  LOG_I(PHY, \"Set UE nb_rx_antenna %d, nb_tx_antenna %d, threequarter_fs %d, ssb_start_subcarrier %d\\n\", fp->nb_antennas_rx, fp->nb_antennas_tx, fp->threequarter_fs, fp->ssb_start_subcarrier);\n\n  fp->ofdm_offset_divisor = nrUE_params.ofdm_offset_divisor;\n  UE->max_ldpc_iterations = nrUE_params.max_ldpc_iterations;\n\n}\n\nvoid init_openair0(void) {\n  int card;\n  int freq_off = 0;\n  NR_DL_FRAME_PARMS *frame_parms = &PHY_vars_UE_g[0][0]->frame_parms;\n\n  for (card=0; card<MAX_CARDS; card++) {\n    uint64_t dl_carrier, ul_carrier;\n    openair0_cfg[card].configFilename    = NULL;\n    openair0_cfg[card].threequarter_fs   = frame_parms->threequarter_fs;\n    openair0_cfg[card].sample_rate       = frame_parms->samples_per_subframe * 1e3;\n    openair0_cfg[card].samples_per_frame = frame_parms->samples_per_frame;\n\n    if (frame_parms->frame_type==TDD)\n      openair0_cfg[card].duplex_mode = duplex_mode_TDD;\n    else\n      openair0_cfg[card].duplex_mode = duplex_mode_FDD;\n\n    openair0_cfg[card].Mod_id = 0;\n    openair0_cfg[card].num_rb_dl = frame_parms->N_RB_DL;\n    openair0_cfg[card].clock_source = get_softmodem_params()->clock_source;\n    openair0_cfg[card].time_source = get_softmodem_params()->timing_source;\n    openair0_cfg[card].tune_offset = get_softmodem_params()->tune_offset;\n    openair0_cfg[card].tx_num_channels = min(4, frame_parms->nb_antennas_tx);\n    openair0_cfg[card].rx_num_channels = min(4, frame_parms->nb_antennas_rx);\n\n    LOG_I(PHY, \"HW: Configuring card %d, sample_rate %f, tx/rx num_channels %d/%d, duplex_mode %s\\n\",\n      card,\n      openair0_cfg[card].sample_rate,\n      openair0_cfg[card].tx_num_channels,\n      openair0_cfg[card].rx_num_channels,\n      duplex_mode[openair0_cfg[card].duplex_mode]);\n\n    nr_get_carrier_frequencies(PHY_vars_UE_g[0][0], &dl_carrier, &ul_carrier);\n\n    nr_rf_card_config_freq(&openair0_cfg[card], ul_carrier, dl_carrier, freq_off);\n    nr_rf_card_config_gain(&openair0_cfg[card], rx_gain_off);\n\n    openair0_cfg[card].configFilename = get_softmodem_params()->rf_config_file;\n\n    if (usrp_args) openair0_cfg[card].sdr_addrs = usrp_args;\n\n  }\n}\n\nstatic void init_pdcp(int ue_id) {\n  uint32_t pdcp_initmask = (!IS_SOFTMODEM_NOS1) ? LINK_ENB_PDCP_TO_GTPV1U_BIT : (LINK_ENB_PDCP_TO_GTPV1U_BIT | PDCP_USE_NETLINK_BIT | LINK_ENB_PDCP_TO_IP_DRIVER_BIT);\n\n  /*if (IS_SOFTMODEM_RFSIM || (nfapi_getmode()==NFAPI_UE_STUB_PNF)) {\n    pdcp_initmask = pdcp_initmask | UE_NAS_USE_TUN_BIT;\n  }*/\n\n  if (IS_SOFTMODEM_NOKRNMOD) {\n    pdcp_initmask = pdcp_initmask | UE_NAS_USE_TUN_BIT;\n  }\n  if (get_softmodem_params()->nsa && rlc_module_init(0) != 0) {\n    LOG_I(RLC, \"Problem at RLC initiation \\n\");\n  }\n  pdcp_layer_init();\n  nr_pdcp_module_init(pdcp_initmask, ue_id);\n  pdcp_set_rlc_data_req_func((send_rlc_data_req_func_t) rlc_data_req);\n  pdcp_set_pdcp_data_ind_func((pdcp_data_ind_func_t) pdcp_data_ind);\n}\n\n// Stupid function addition because UE itti messages queues definition is common with eNB\nvoid *rrc_enb_process_msg(void *notUsed) {\n  return NULL;\n}\n\n\nint main( int argc, char **argv ) {\n  int set_exe_prio = 1;\n  if (checkIfFedoraDistribution())\n    if (checkIfGenericKernelOnFedora())\n      if (checkIfInsideContainer())\n        set_exe_prio = 0;\n  if (set_exe_prio)\n    set_priority(79);\n\n  if (mlockall(MCL_CURRENT | MCL_FUTURE) == -1)\n  {\n    fprintf(stderr, \"mlockall: %s\\n\", strerror(errno));\n    return EXIT_FAILURE;\n  }\n\n  //uint8_t beta_ACK=0,beta_RI=0,beta_CQI=2;\n  PHY_VARS_NR_UE *UE[MAX_NUM_CCs];\n  start_background_system();\n\n  if ( load_configmodule(argc,argv,CONFIG_ENABLECMDLINEONLY) == NULL) {\n    exit_fun(\"[SOFTMODEM] Error, configuration module init failed\\n\");\n  }\n  set_softmodem_sighandler();\n  CONFIG_SETRTFLAG(CONFIG_NOEXITONHELP);\n  memset(openair0_cfg,0,sizeof(openair0_config_t)*MAX_CARDS);\n  memset(tx_max_power,0,sizeof(int)*MAX_NUM_CCs);\n  // initialize logging\n  logInit();\n  // get options and fill parameters from configuration file\n\n  get_options (); //Command-line options specific for NRUE\n\n  get_common_options(SOFTMODEM_5GUE_BIT);\n  CONFIG_CLEARRTFLAG(CONFIG_NOEXITONHELP);\n#if T_TRACER\n  T_Config_Init();\n#endif\n  init_tpools(nrUE_params.nr_dlsch_parallel);\n  //randominit (0);\n  set_taus_seed (0);\n\n  cpuf=get_cpu_freq_GHz();\n  itti_init(TASK_MAX, tasks_info);\n\n  init_opt() ;\n  load_nrLDPClib(NULL);\n\n  if (ouput_vcd) {\n    vcd_signal_dumper_init(\"/tmp/openair_dump_nrUE.vcd\");\n  }\n\n  #ifndef PACKAGE_VERSION\n#  define PACKAGE_VERSION \"UNKNOWN-EXPERIMENTAL\"\n#endif\n  LOG_I(HW, \"Version: %s\\n\", PACKAGE_VERSION);\n\n  init_NR_UE(1,uecap_file,rrc_config_path);\n\n  int mode_offset = get_softmodem_params()->nsa ? NUMBER_OF_UE_MAX : 1;\n  uint16_t node_number = get_softmodem_params()->node_number;\n  ue_id_g = (node_number == 0) ? 0 : node_number - 2;\n  AssertFatal(ue_id_g >= 0, \"UE id is expected to be nonnegative.\\n\");\n  if(IS_SOFTMODEM_NOS1 || get_softmodem_params()->sa || get_softmodem_params()->nsa) {\n    if(node_number == 0) {\n      init_pdcp(0);\n    }\n    else {\n      init_pdcp(mode_offset + ue_id_g);\n    }\n  }\n\n  NB_UE_INST=1;\n  NB_INST=1;\n  PHY_vars_UE_g = malloc(sizeof(PHY_VARS_NR_UE **));\n  PHY_vars_UE_g[0] = malloc(sizeof(PHY_VARS_NR_UE *)*MAX_NUM_CCs);\n  if (get_softmodem_params()->emulate_l1) {\n    RCconfig_nr_ue_L1();\n    init_bler_table();\n  }\n\n  if (get_softmodem_params()->do_ra)\n    AssertFatal(get_softmodem_params()->phy_test == 0,\"RA and phy_test are mutually exclusive\\n\");\n\n  if (get_softmodem_params()->sa)\n    AssertFatal(get_softmodem_params()->phy_test == 0,\"Standalone mode and phy_test are mutually exclusive\\n\");\n\n  if (!get_softmodem_params()->nsa && get_softmodem_params()->emulate_l1)\n    start_oai_nrue_threads();\n\n  if (!get_softmodem_params()->emulate_l1) {\n    for (int CC_id=0; CC_id<MAX_NUM_CCs; CC_id++) {\n      PHY_vars_UE_g[0][CC_id] = (PHY_VARS_NR_UE *)malloc(sizeof(PHY_VARS_NR_UE));\n      UE[CC_id] = PHY_vars_UE_g[0][CC_id];\n      memset(UE[CC_id],0,sizeof(PHY_VARS_NR_UE));\n\n      set_options(CC_id, UE[CC_id]);\n      NR_UE_MAC_INST_t *mac = get_mac_inst(0);\n\n      if (get_softmodem_params()->sa) { // set frame config to initial values from command line and assume that the SSB is centered on the grid\n        uint16_t nr_band = get_band(downlink_frequency[CC_id][0],uplink_frequency_offset[CC_id][0]);\n        mac->nr_band = nr_band;\n        nr_init_frame_parms_ue_sa(&UE[CC_id]->frame_parms,\n                                  downlink_frequency[CC_id][0],\n                                  uplink_frequency_offset[CC_id][0],\n                                  get_softmodem_params()->numerology,\n                                  nr_band);\n      }\n      else{\n        if(mac->if_module != NULL && mac->if_module->phy_config_request != NULL)\n          mac->if_module->phy_config_request(&mac->phy_config);\n\n        fapi_nr_config_request_t *nrUE_config = &UE[CC_id]->nrUE_config;\n\n        nr_init_frame_parms_ue(&UE[CC_id]->frame_parms, nrUE_config,\n            *mac->scc->downlinkConfigCommon->frequencyInfoDL->frequencyBandList.list.array[0]);\n      }\n\n      init_symbol_rotation(&UE[CC_id]->frame_parms);\n      init_timeshift_rotation(&UE[CC_id]->frame_parms);\n      init_nr_ue_vars(UE[CC_id], 0, abstraction_flag);\n    }\n\n    init_openair0();\n    // init UE_PF_PO and mutex lock\n    pthread_mutex_init(&ue_pf_po_mutex, NULL);\n    memset (&UE_PF_PO[0][0], 0, sizeof(UE_PF_PO_t)*NUMBER_OF_UE_MAX*MAX_NUM_CCs);\n    set_latency_target();\n    mlockall(MCL_CURRENT | MCL_FUTURE);\n\n    if(IS_SOFTMODEM_DOSCOPE) {\n      load_softscope(\"nr\",PHY_vars_UE_g[0][0]);\n    }\n\n    init_NR_UE_threads(1);\n    printf(\"UE threads created by %ld\\n\", gettid());\n  }\n\n  // wait for end of program\n  printf(\"TYPE <CTRL-C> TO TERMINATE\\n\");\n\n  if (create_tasks_nrue(1) < 0) {\n    printf(\"cannot create ITTI tasks\\n\");\n    exit(-1); // need a softer mode\n  }\n\n  // Sleep a while before checking all parameters have been used\n  // Some are used directly in external threads, asynchronously\n  sleep(20);\n  config_check_unknown_cmdlineopt(CONFIG_CHECKALLSECTIONS);\n\n  while(true)\n    sleep(3600);\n\n  if (ouput_vcd)\n    vcd_signal_dumper_close();\n\n  return 0;\n}\n\n// Read in each MCS file and build BLER-SINR-TB table\nstatic void init_bler_table(void) {\n  memset(nr_bler_data, 0, sizeof(nr_bler_data));\n\n  const char *awgn_results_dir = getenv(\"AWGN_RESULTS_DIR\");\n  if (!awgn_results_dir) {\n    LOG_W(NR_MAC, \"No $AWGN_RESULTS_DIR\\n\");\n    return;\n  }\n\n  for (unsigned int i = 0; i < NR_NUM_MCS; i++) {\n    char fName[1024];\n    snprintf(fName, sizeof(fName), \"%s/mcs%d_awgn_5G.csv\", awgn_results_dir, i);\n    FILE *pFile = fopen(fName, \"r\");\n    if (!pFile) {\n      LOG_E(NR_MAC, \"%s: open %s: %s\\n\", __func__, fName, strerror(errno));\n      continue;\n    }\n    size_t bufSize = 1024;\n    char * line = NULL;\n    char * token;\n    char * temp = NULL;\n    int nlines = 0;\n    while (getline(&line, &bufSize, pFile) > 0) {\n      if (!strncmp(line, \"SNR\", 3)) {\n        continue;\n      }\n\n      if (nlines > NUM_SINR) {\n        LOG_E(NR_MAC, \"BLER FILE ERROR - num lines greater than expected - file: %s\\n\", fName);\n        abort();\n      }\n\n      token = strtok_r(line, \";\", &temp);\n      int ncols = 0;\n      while (token != NULL) {\n        if (ncols > NUM_BLER_COL) {\n          LOG_E(NR_MAC, \"BLER FILE ERROR - num of cols greater than expected\\n\");\n          abort();\n        }\n\n        nr_bler_data[i].bler_table[nlines][ncols] = strtof(token, NULL);\n        ncols++;\n\n        token = strtok_r(NULL, \";\", &temp);\n      }\n      nlines++;\n    }\n    nr_bler_data[i].length = nlines;\n    fclose(pFile);\n  }\n}\n"
    },
    {
      "file": "executables/softmodem-common.c",
      "description": "executables/softmodem-common.c/get_common_options() Line 87 (callee)",
      "line": 87,
      "contents": "/*\n * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The OpenAirInterface Software Alliance licenses this file to You under\n * the OAI Public License, Version 1.1  (the \"License\"); you may not use this file\n * except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.openairinterface.org/?page_id=698\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *-------------------------------------------------------------------------------\n * For more information about the OpenAirInterface (OAI) Software Alliance:\n *      contact@openairinterface.org\n */\n\n/*! \\file lte-softmodem-common.c\n * \\brief common code for 5G and LTE softmodem main xNB and UEs source (nr-softmodem.c, lte-softmodem.c...)\n * \\author Nokia BellLabs France, francois Taburet\n * \\date 2020\n * \\version 0.1\n * \\company Nokia BellLabs France\n * \\email: francois.taburet@nokia-bell-labs.com\n * \\note\n * \\warning\n */\n#include <time.h>\n#include <dlfcn.h>\n#include <sys/resource.h>\n#include \"UTIL/OPT/opt.h\"\n#include \"common/config/config_userapi.h\"\n#include \"common/utils/load_module_shlib.h\"\n#include \"common/utils/telnetsrv/telnetsrv.h\"\n#include \"executables/thread-common.h\"\n#include \"common/utils/LOG/log.h\"\n#include \"softmodem-common.h\"\n#include \"nfapi/oai_integration/vendor_ext.h\"\n\n\nstatic softmodem_params_t softmodem_params;\nchar *parallel_config=NULL;\nchar *worker_config=NULL;\nint usrp_tx_thread = 0;\n\nuint8_t nfapi_mode=0;\n\nstatic mapping softmodem_funcs[] = MAPPING_SOFTMODEM_FUNCTIONS;\nstatic struct timespec start;\n\nuint64_t get_softmodem_optmask(void) {\n  return softmodem_params.optmask;\n}\n\nuint64_t set_softmodem_optmask(uint64_t bitmask) {\n  softmodem_params.optmask = softmodem_params.optmask | bitmask;\n  return softmodem_params.optmask;\n}\n\nsoftmodem_params_t *get_softmodem_params(void) {\n  return &softmodem_params;\n}\n\nint32_t check_execmask(uint64_t execmask) {\n  char *softmodemfunc=map_int_to_str(softmodem_funcs, execmask);\n  if (softmodemfunc != NULL) {\n  \t  set_softmodem_optmask(execmask);\n  \t  return 0;\n  } \n  return -1;\n}\nchar *get_softmodem_function(uint64_t *sofmodemfunc_mask_ptr) {\n  uint64_t fmask=(get_softmodem_optmask()&SOFTMODEM_FUNC_BITS);\n  char *softmodemfunc=map_int_to_str(softmodem_funcs, fmask);\n  if (sofmodemfunc_mask_ptr != NULL)\n  \t  *sofmodemfunc_mask_ptr=fmask;\n  if (softmodemfunc != NULL) {\n  \t  return softmodemfunc;\n  }\n  return \"???\";\n}\n\nvoid get_common_options(uint32_t execmask) {\n  int32_t stats_disabled = 0;\n  uint32_t online_log_messages=0;\n  uint32_t glog_level=0 ;\n  uint32_t start_telnetsrv = 0, start_telnetclt = 0;\n  uint32_t noS1 = 0, nokrnmod = 1, nonbiot = 0;\n  uint32_t rfsim = 0, do_forms = 0;\n  char *logmem_filename = NULL;\n  paramdef_t cmdline_params[] =CMDLINE_PARAMS_DESC ;\n  paramdef_t cmdline_logparams[] =CMDLINE_LOGPARAMS_DESC ;\n  checkedparam_t cmdline_log_CheckParams[] = CMDLINE_LOGPARAMS_CHECK_DESC;\n  check_execmask(execmask);\n  config_get( cmdline_params,sizeof(cmdline_params)/sizeof(paramdef_t),NULL);\n  \n  int numparams=sizeof(cmdline_logparams)/sizeof(paramdef_t);\n  config_set_checkfunctions(cmdline_logparams, cmdline_log_CheckParams,numparams);\n  config_get( cmdline_logparams,numparams,NULL);\n  \n  if(config_isparamset(cmdline_logparams,config_paramidx_fromname(cmdline_logparams,numparams, CONFIG_FLOG_OPT))) {\n    set_glog_onlinelog(online_log_messages);\n  }\n\n  if(config_isparamset(cmdline_logparams,config_paramidx_fromname(cmdline_logparams,numparams, CONFIG_LOGL_OPT))) {\n    set_glog(glog_level);\n  }\n\n  if (start_telnetsrv) {\n    load_module_shlib(\"telnetsrv\",NULL,0,NULL);\n  }\n  \n  if (start_telnetclt) {\n    set_softmodem_optmask(SOFTMODEM_TELNETCLT_BIT);\n  }\n\n  if (logmem_filename != NULL && strlen(logmem_filename) > 0) {\n    log_mem_filename = &logmem_filename[0];\n    log_mem_flag = 1;\n    printf(\"Enabling OPT for log save at memory %s\\n\",log_mem_filename);\n    logInit_log_mem();\n  }\n\n  if (noS1) {\n    set_softmodem_optmask(SOFTMODEM_NOS1_BIT);\n  }\n\n  if (nokrnmod) {\n    printf(\"nokrnmod bit enabled \\n\");\n    set_softmodem_optmask(SOFTMODEM_NOKRNMOD_BIT);\n  }\n\n  if (nonbiot) {\n    set_softmodem_optmask(SOFTMODEM_NONBIOT_BIT);\n  }\n\n  if (rfsim) {\n    set_softmodem_optmask(SOFTMODEM_RFSIM_BIT);\n  }\n\n  if (do_forms) {\n    set_softmodem_optmask(SOFTMODEM_DOSCOPE_BIT);\n  }\n\n  if(parallel_config != NULL) set_parallel_conf(parallel_config);\n\n  if(worker_config != NULL)   set_worker_conf(worker_config);\n  nfapi_setmode(nfapi_mode);\n  if (stats_disabled)\n    set_softmodem_optmask(SOFTMODEM_NOSTATS_BIT);\n}\nvoid softmodem_printresources(int sig, telnet_printfunc_t pf) {\n  struct rusage usage;\n  struct timespec stop;\n\n  clock_gettime(CLOCK_BOOTTIME, &stop);\n\n  uint64_t elapse = (stop.tv_sec - start.tv_sec) ;   // in seconds\n\n\n  int st = getrusage(RUSAGE_SELF,&usage);\n  if (!st) {\n    pf(\"\\nRun time: %lluh %llus\\n\",(unsigned long long)elapse/3600,(unsigned long long)(elapse - (elapse/3600)));\n    pf(\"\\tTime executing user inst.: %lds %ldus\\n\",(long)usage.ru_utime.tv_sec,(long)usage.ru_utime.tv_usec);\n    pf(\"\\tTime executing system inst.: %lds %ldus\\n\",(long)usage.ru_stime.tv_sec,(long)usage.ru_stime.tv_usec);\n    pf(\"\\tMax. Phy. memory usage: %ldkB\\n\",(long)usage.ru_maxrss);\n    pf(\"\\tPage fault number (no io): %ld\\n\",(long)usage.ru_minflt);\n    pf(\"\\tPage fault number (requiring io): %ld\\n\",(long)usage.ru_majflt);\n    pf(\"\\tNumber of file system read: %ld\\n\",(long)usage.ru_inblock);\n    pf(\"\\tNumber of filesystem write: %ld\\n\",(long)usage.ru_oublock);\n    pf(\"\\tNumber of context switch (process origin, io...): %ld\\n\",(long)usage.ru_nvcsw);\n    pf(\"\\tNumber of context switch (os origin, priority...): %ld\\n\",(long)usage.ru_nivcsw);\n  }\n}\n\nvoid signal_handler(int sig) {\n  //void *array[10];\n  //size_t size;\n\n  if (sig==SIGSEGV) {\n    // get void*'s for all entries on the stack\n    /* backtrace uses malloc, that is not good in signal handlers\n     * I let the code, because it would be nice to make it better\n    size = backtrace(array, 10);\n    // print out all the frames to stderr\n    fprintf(stderr, \"Error: signal %d:\\n\", sig);\n    backtrace_symbols_fd(array, size, 2);\n    */\n    exit(-1);\n  } else {\n    if(sig==SIGINT ||sig==SOFTMODEM_RTSIGNAL)\n      softmodem_printresources(sig,(telnet_printfunc_t)printf);\n    if (sig != SOFTMODEM_RTSIGNAL) {\n      printf(\"Linux signal %s...\\n\",strsignal(sig));\n      exit_function(__FILE__, __FUNCTION__, __LINE__,\"softmodem starting exit procedure\\n\");\n    }\n  }\n}\n\n\n\nvoid set_softmodem_sighandler(void) {\n  struct sigaction  act,oldact;\n  clock_gettime(CLOCK_BOOTTIME, &start);\n  memset(&act,0,sizeof(act));\n  act.sa_handler=signal_handler;\n  sigaction(SOFTMODEM_RTSIGNAL,&act,&oldact);\n  // Disabled in order generate a core dump for analysis with gdb\n  # if 0\n  printf(\"Send signal %d to display resource usage...\\n\",SIGRTMIN+1);\n  signal(SIGSEGV, signal_handler);\n  signal(SIGINT,  signal_handler);\n  signal(SIGTERM, signal_handler);\n  signal(SIGABRT, signal_handler);\n  #endif\n}\n\n"
    },
    {
      "file": "executables/softmodem-common.c",
      "description": "executables/softmodem-common.c/get_common_options() Line 152 (call nfapi_setmode())",
      "line": 152,
      "contents": "/*\n * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The OpenAirInterface Software Alliance licenses this file to You under\n * the OAI Public License, Version 1.1  (the \"License\"); you may not use this file\n * except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.openairinterface.org/?page_id=698\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *-------------------------------------------------------------------------------\n * For more information about the OpenAirInterface (OAI) Software Alliance:\n *      contact@openairinterface.org\n */\n\n/*! \\file lte-softmodem-common.c\n * \\brief common code for 5G and LTE softmodem main xNB and UEs source (nr-softmodem.c, lte-softmodem.c...)\n * \\author Nokia BellLabs France, francois Taburet\n * \\date 2020\n * \\version 0.1\n * \\company Nokia BellLabs France\n * \\email: francois.taburet@nokia-bell-labs.com\n * \\note\n * \\warning\n */\n#include <time.h>\n#include <dlfcn.h>\n#include <sys/resource.h>\n#include \"UTIL/OPT/opt.h\"\n#include \"common/config/config_userapi.h\"\n#include \"common/utils/load_module_shlib.h\"\n#include \"common/utils/telnetsrv/telnetsrv.h\"\n#include \"executables/thread-common.h\"\n#include \"common/utils/LOG/log.h\"\n#include \"softmodem-common.h\"\n#include \"nfapi/oai_integration/vendor_ext.h\"\n\n\nstatic softmodem_params_t softmodem_params;\nchar *parallel_config=NULL;\nchar *worker_config=NULL;\nint usrp_tx_thread = 0;\n\nuint8_t nfapi_mode=0;\n\nstatic mapping softmodem_funcs[] = MAPPING_SOFTMODEM_FUNCTIONS;\nstatic struct timespec start;\n\nuint64_t get_softmodem_optmask(void) {\n  return softmodem_params.optmask;\n}\n\nuint64_t set_softmodem_optmask(uint64_t bitmask) {\n  softmodem_params.optmask = softmodem_params.optmask | bitmask;\n  return softmodem_params.optmask;\n}\n\nsoftmodem_params_t *get_softmodem_params(void) {\n  return &softmodem_params;\n}\n\nint32_t check_execmask(uint64_t execmask) {\n  char *softmodemfunc=map_int_to_str(softmodem_funcs, execmask);\n  if (softmodemfunc != NULL) {\n  \t  set_softmodem_optmask(execmask);\n  \t  return 0;\n  } \n  return -1;\n}\nchar *get_softmodem_function(uint64_t *sofmodemfunc_mask_ptr) {\n  uint64_t fmask=(get_softmodem_optmask()&SOFTMODEM_FUNC_BITS);\n  char *softmodemfunc=map_int_to_str(softmodem_funcs, fmask);\n  if (sofmodemfunc_mask_ptr != NULL)\n  \t  *sofmodemfunc_mask_ptr=fmask;\n  if (softmodemfunc != NULL) {\n  \t  return softmodemfunc;\n  }\n  return \"???\";\n}\n\nvoid get_common_options(uint32_t execmask) {\n  int32_t stats_disabled = 0;\n  uint32_t online_log_messages=0;\n  uint32_t glog_level=0 ;\n  uint32_t start_telnetsrv = 0, start_telnetclt = 0;\n  uint32_t noS1 = 0, nokrnmod = 1, nonbiot = 0;\n  uint32_t rfsim = 0, do_forms = 0;\n  char *logmem_filename = NULL;\n  paramdef_t cmdline_params[] =CMDLINE_PARAMS_DESC ;\n  paramdef_t cmdline_logparams[] =CMDLINE_LOGPARAMS_DESC ;\n  checkedparam_t cmdline_log_CheckParams[] = CMDLINE_LOGPARAMS_CHECK_DESC;\n  check_execmask(execmask);\n  config_get( cmdline_params,sizeof(cmdline_params)/sizeof(paramdef_t),NULL);\n  \n  int numparams=sizeof(cmdline_logparams)/sizeof(paramdef_t);\n  config_set_checkfunctions(cmdline_logparams, cmdline_log_CheckParams,numparams);\n  config_get( cmdline_logparams,numparams,NULL);\n  \n  if(config_isparamset(cmdline_logparams,config_paramidx_fromname(cmdline_logparams,numparams, CONFIG_FLOG_OPT))) {\n    set_glog_onlinelog(online_log_messages);\n  }\n\n  if(config_isparamset(cmdline_logparams,config_paramidx_fromname(cmdline_logparams,numparams, CONFIG_LOGL_OPT))) {\n    set_glog(glog_level);\n  }\n\n  if (start_telnetsrv) {\n    load_module_shlib(\"telnetsrv\",NULL,0,NULL);\n  }\n  \n  if (start_telnetclt) {\n    set_softmodem_optmask(SOFTMODEM_TELNETCLT_BIT);\n  }\n\n  if (logmem_filename != NULL && strlen(logmem_filename) > 0) {\n    log_mem_filename = &logmem_filename[0];\n    log_mem_flag = 1;\n    printf(\"Enabling OPT for log save at memory %s\\n\",log_mem_filename);\n    logInit_log_mem();\n  }\n\n  if (noS1) {\n    set_softmodem_optmask(SOFTMODEM_NOS1_BIT);\n  }\n\n  if (nokrnmod) {\n    printf(\"nokrnmod bit enabled \\n\");\n    set_softmodem_optmask(SOFTMODEM_NOKRNMOD_BIT);\n  }\n\n  if (nonbiot) {\n    set_softmodem_optmask(SOFTMODEM_NONBIOT_BIT);\n  }\n\n  if (rfsim) {\n    set_softmodem_optmask(SOFTMODEM_RFSIM_BIT);\n  }\n\n  if (do_forms) {\n    set_softmodem_optmask(SOFTMODEM_DOSCOPE_BIT);\n  }\n\n  if(parallel_config != NULL) set_parallel_conf(parallel_config);\n\n  if(worker_config != NULL)   set_worker_conf(worker_config);\n  nfapi_setmode(nfapi_mode);\n  if (stats_disabled)\n    set_softmodem_optmask(SOFTMODEM_NOSTATS_BIT);\n}\nvoid softmodem_printresources(int sig, telnet_printfunc_t pf) {\n  struct rusage usage;\n  struct timespec stop;\n\n  clock_gettime(CLOCK_BOOTTIME, &stop);\n\n  uint64_t elapse = (stop.tv_sec - start.tv_sec) ;   // in seconds\n\n\n  int st = getrusage(RUSAGE_SELF,&usage);\n  if (!st) {\n    pf(\"\\nRun time: %lluh %llus\\n\",(unsigned long long)elapse/3600,(unsigned long long)(elapse - (elapse/3600)));\n    pf(\"\\tTime executing user inst.: %lds %ldus\\n\",(long)usage.ru_utime.tv_sec,(long)usage.ru_utime.tv_usec);\n    pf(\"\\tTime executing system inst.: %lds %ldus\\n\",(long)usage.ru_stime.tv_sec,(long)usage.ru_stime.tv_usec);\n    pf(\"\\tMax. Phy. memory usage: %ldkB\\n\",(long)usage.ru_maxrss);\n    pf(\"\\tPage fault number (no io): %ld\\n\",(long)usage.ru_minflt);\n    pf(\"\\tPage fault number (requiring io): %ld\\n\",(long)usage.ru_majflt);\n    pf(\"\\tNumber of file system read: %ld\\n\",(long)usage.ru_inblock);\n    pf(\"\\tNumber of filesystem write: %ld\\n\",(long)usage.ru_oublock);\n    pf(\"\\tNumber of context switch (process origin, io...): %ld\\n\",(long)usage.ru_nvcsw);\n    pf(\"\\tNumber of context switch (os origin, priority...): %ld\\n\",(long)usage.ru_nivcsw);\n  }\n}\n\nvoid signal_handler(int sig) {\n  //void *array[10];\n  //size_t size;\n\n  if (sig==SIGSEGV) {\n    // get void*'s for all entries on the stack\n    /* backtrace uses malloc, that is not good in signal handlers\n     * I let the code, because it would be nice to make it better\n    size = backtrace(array, 10);\n    // print out all the frames to stderr\n    fprintf(stderr, \"Error: signal %d:\\n\", sig);\n    backtrace_symbols_fd(array, size, 2);\n    */\n    exit(-1);\n  } else {\n    if(sig==SIGINT ||sig==SOFTMODEM_RTSIGNAL)\n      softmodem_printresources(sig,(telnet_printfunc_t)printf);\n    if (sig != SOFTMODEM_RTSIGNAL) {\n      printf(\"Linux signal %s...\\n\",strsignal(sig));\n      exit_function(__FILE__, __FUNCTION__, __LINE__,\"softmodem starting exit procedure\\n\");\n    }\n  }\n}\n\n\n\nvoid set_softmodem_sighandler(void) {\n  struct sigaction  act,oldact;\n  clock_gettime(CLOCK_BOOTTIME, &start);\n  memset(&act,0,sizeof(act));\n  act.sa_handler=signal_handler;\n  sigaction(SOFTMODEM_RTSIGNAL,&act,&oldact);\n  // Disabled in order generate a core dump for analysis with gdb\n  # if 0\n  printf(\"Send signal %d to display resource usage...\\n\",SIGRTMIN+1);\n  signal(SIGSEGV, signal_handler);\n  signal(SIGINT,  signal_handler);\n  signal(SIGTERM, signal_handler);\n  signal(SIGABRT, signal_handler);\n  #endif\n}\n\n"
    },
    {
      "file": "nfapi/oai_integration/nfapi.c",
      "description": "nfapi/oai_integration/nfapi.c/nfapi_setmode() Line 74 (callee)",
      "line": 74,
      "contents": "/*\n * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The OpenAirInterface Software Alliance licenses this file to You under\n * the OAI Public License, Version 1.1  (the \"License\"); you may not use this file\n * except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.openairinterface.org/?page_id=698\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *-------------------------------------------------------------------------------\n * For more information about the OpenAirInterface (OAI) Software Alliance:\n *      contact@openairinterface.org\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include \"nfapi/oai_integration/vendor_ext.h\"\n#include \"common/utils/LOG/log.h\"\nstatic const char *const nfapi_str_mode[] = {\n    \"MONOLITHIC\",\n    \"PNF\",\n    \"VNF\",\n    \"UE_STUB_PNF\",\n    \"UE_STUB_OFFNET\",\n    \"STANDALONE_PNF\",\n    \"<UNKNOWN NFAPI MODE>\"\n};\n\ntypedef struct {\n  nfapi_mode_t nfapi_mode;\n} nfapi_params_t;\n\nstatic nfapi_params_t nfapi_params = {0};\n\nvoid set_thread_priority(int priority) {\n  set_priority(priority);\n\n  pthread_attr_t ptAttr;\n  if(pthread_attr_setschedpolicy(&ptAttr, SCHED_RR) != 0) {\n    printf(\"Failed to set pthread sched policy SCHED_RR\\n\");\n  }\n\n  pthread_attr_setinheritsched(&ptAttr, PTHREAD_EXPLICIT_SCHED);\n  struct sched_param thread_params;\n  thread_params.sched_priority = 20;\n\n  if(pthread_attr_setschedparam(&ptAttr, &thread_params) != 0) {\n    printf(\"failed to set sched param\\n\");\n  }\n}\n\nconst char *nfapi_get_strmode(void) {\n  if (nfapi_params.nfapi_mode > NFAPI_MODE_UNKNOWN)\n    return nfapi_str_mode[NFAPI_MODE_UNKNOWN];\n\n  return nfapi_str_mode[nfapi_params.nfapi_mode];\n}\n\nvoid nfapi_logmode() {\n  LOG_I(ENB_APP,\"nfapi running mode: %s\\n\",nfapi_get_strmode());\n}\n\nnfapi_mode_t nfapi_getmode(void) {\n  return nfapi_params.nfapi_mode;\n}\n\nvoid nfapi_setmode(nfapi_mode_t nfapi_mode) {\n  nfapi_params.nfapi_mode = nfapi_mode;\n  nfapi_logmode();\n}\n"
    },
    {
      "file": "nfapi/oai_integration/nfapi.c",
      "description": "nfapi/oai_integration/nfapi.c/nfapi_setmode() Line 76 (call nfapi_logmode())",
      "line": 76,
      "contents": "/*\n * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The OpenAirInterface Software Alliance licenses this file to You under\n * the OAI Public License, Version 1.1  (the \"License\"); you may not use this file\n * except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.openairinterface.org/?page_id=698\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *-------------------------------------------------------------------------------\n * For more information about the OpenAirInterface (OAI) Software Alliance:\n *      contact@openairinterface.org\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include \"nfapi/oai_integration/vendor_ext.h\"\n#include \"common/utils/LOG/log.h\"\nstatic const char *const nfapi_str_mode[] = {\n    \"MONOLITHIC\",\n    \"PNF\",\n    \"VNF\",\n    \"UE_STUB_PNF\",\n    \"UE_STUB_OFFNET\",\n    \"STANDALONE_PNF\",\n    \"<UNKNOWN NFAPI MODE>\"\n};\n\ntypedef struct {\n  nfapi_mode_t nfapi_mode;\n} nfapi_params_t;\n\nstatic nfapi_params_t nfapi_params = {0};\n\nvoid set_thread_priority(int priority) {\n  set_priority(priority);\n\n  pthread_attr_t ptAttr;\n  if(pthread_attr_setschedpolicy(&ptAttr, SCHED_RR) != 0) {\n    printf(\"Failed to set pthread sched policy SCHED_RR\\n\");\n  }\n\n  pthread_attr_setinheritsched(&ptAttr, PTHREAD_EXPLICIT_SCHED);\n  struct sched_param thread_params;\n  thread_params.sched_priority = 20;\n\n  if(pthread_attr_setschedparam(&ptAttr, &thread_params) != 0) {\n    printf(\"failed to set sched param\\n\");\n  }\n}\n\nconst char *nfapi_get_strmode(void) {\n  if (nfapi_params.nfapi_mode > NFAPI_MODE_UNKNOWN)\n    return nfapi_str_mode[NFAPI_MODE_UNKNOWN];\n\n  return nfapi_str_mode[nfapi_params.nfapi_mode];\n}\n\nvoid nfapi_logmode() {\n  LOG_I(ENB_APP,\"nfapi running mode: %s\\n\",nfapi_get_strmode());\n}\n\nnfapi_mode_t nfapi_getmode(void) {\n  return nfapi_params.nfapi_mode;\n}\n\nvoid nfapi_setmode(nfapi_mode_t nfapi_mode) {\n  nfapi_params.nfapi_mode = nfapi_mode;\n  nfapi_logmode();\n}\n"
    },
    {
      "file": "nfapi/oai_integration/nfapi.c",
      "description": "nfapi/oai_integration/nfapi.c/nfapi_logmode() Line 66 (callee)",
      "line": 66,
      "contents": "/*\n * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The OpenAirInterface Software Alliance licenses this file to You under\n * the OAI Public License, Version 1.1  (the \"License\"); you may not use this file\n * except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.openairinterface.org/?page_id=698\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *-------------------------------------------------------------------------------\n * For more information about the OpenAirInterface (OAI) Software Alliance:\n *      contact@openairinterface.org\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include \"nfapi/oai_integration/vendor_ext.h\"\n#include \"common/utils/LOG/log.h\"\nstatic const char *const nfapi_str_mode[] = {\n    \"MONOLITHIC\",\n    \"PNF\",\n    \"VNF\",\n    \"UE_STUB_PNF\",\n    \"UE_STUB_OFFNET\",\n    \"STANDALONE_PNF\",\n    \"<UNKNOWN NFAPI MODE>\"\n};\n\ntypedef struct {\n  nfapi_mode_t nfapi_mode;\n} nfapi_params_t;\n\nstatic nfapi_params_t nfapi_params = {0};\n\nvoid set_thread_priority(int priority) {\n  set_priority(priority);\n\n  pthread_attr_t ptAttr;\n  if(pthread_attr_setschedpolicy(&ptAttr, SCHED_RR) != 0) {\n    printf(\"Failed to set pthread sched policy SCHED_RR\\n\");\n  }\n\n  pthread_attr_setinheritsched(&ptAttr, PTHREAD_EXPLICIT_SCHED);\n  struct sched_param thread_params;\n  thread_params.sched_priority = 20;\n\n  if(pthread_attr_setschedparam(&ptAttr, &thread_params) != 0) {\n    printf(\"failed to set sched param\\n\");\n  }\n}\n\nconst char *nfapi_get_strmode(void) {\n  if (nfapi_params.nfapi_mode > NFAPI_MODE_UNKNOWN)\n    return nfapi_str_mode[NFAPI_MODE_UNKNOWN];\n\n  return nfapi_str_mode[nfapi_params.nfapi_mode];\n}\n\nvoid nfapi_logmode() {\n  LOG_I(ENB_APP,\"nfapi running mode: %s\\n\",nfapi_get_strmode());\n}\n\nnfapi_mode_t nfapi_getmode(void) {\n  return nfapi_params.nfapi_mode;\n}\n\nvoid nfapi_setmode(nfapi_mode_t nfapi_mode) {\n  nfapi_params.nfapi_mode = nfapi_mode;\n  nfapi_logmode();\n}\n"
    },
    {
      "file": "nfapi/oai_integration/nfapi.c",
      "description": "nfapi/oai_integration/nfapi.c/nfapi_logmode() Line 67 (PRINT)",
      "line": 67,
      "contents": "/*\n * Licensed to the OpenAirInterface (OAI) Software Alliance under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The OpenAirInterface Software Alliance licenses this file to You under\n * the OAI Public License, Version 1.1  (the \"License\"); you may not use this file\n * except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.openairinterface.org/?page_id=698\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *-------------------------------------------------------------------------------\n * For more information about the OpenAirInterface (OAI) Software Alliance:\n *      contact@openairinterface.org\n */\n\n#include <stdio.h>\n#include <pthread.h>\n#include \"nfapi/oai_integration/vendor_ext.h\"\n#include \"common/utils/LOG/log.h\"\nstatic const char *const nfapi_str_mode[] = {\n    \"MONOLITHIC\",\n    \"PNF\",\n    \"VNF\",\n    \"UE_STUB_PNF\",\n    \"UE_STUB_OFFNET\",\n    \"STANDALONE_PNF\",\n    \"<UNKNOWN NFAPI MODE>\"\n};\n\ntypedef struct {\n  nfapi_mode_t nfapi_mode;\n} nfapi_params_t;\n\nstatic nfapi_params_t nfapi_params = {0};\n\nvoid set_thread_priority(int priority) {\n  set_priority(priority);\n\n  pthread_attr_t ptAttr;\n  if(pthread_attr_setschedpolicy(&ptAttr, SCHED_RR) != 0) {\n    printf(\"Failed to set pthread sched policy SCHED_RR\\n\");\n  }\n\n  pthread_attr_setinheritsched(&ptAttr, PTHREAD_EXPLICIT_SCHED);\n  struct sched_param thread_params;\n  thread_params.sched_priority = 20;\n\n  if(pthread_attr_setschedparam(&ptAttr, &thread_params) != 0) {\n    printf(\"failed to set sched param\\n\");\n  }\n}\n\nconst char *nfapi_get_strmode(void) {\n  if (nfapi_params.nfapi_mode > NFAPI_MODE_UNKNOWN)\n    return nfapi_str_mode[NFAPI_MODE_UNKNOWN];\n\n  return nfapi_str_mode[nfapi_params.nfapi_mode];\n}\n\nvoid nfapi_logmode() {\n  LOG_I(ENB_APP,\"nfapi running mode: %s\\n\",nfapi_get_strmode());\n}\n\nnfapi_mode_t nfapi_getmode(void) {\n  return nfapi_params.nfapi_mode;\n}\n\nvoid nfapi_setmode(nfapi_mode_t nfapi_mode) {\n  nfapi_params.nfapi_mode = nfapi_mode;\n  nfapi_logmode();\n}\n"
    }
  ]
}